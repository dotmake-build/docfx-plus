<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net8.0</TargetFramework>
    <Product>DotMake Docfx-Plus Cli</Product>
    <AssemblyName>docfx-plus</AssemblyName>
    <RollForward>Major</RollForward>
    <SatelliteResourceLanguages>en</SatelliteResourceLanguages>

    <PackAsTool>true</PackAsTool>
    <ToolCommandName>docfx-plus</ToolCommandName>
    <!-- NuGet Package Information (common ones are in Directory.Build.props) -->
    <!-- Description is used for assembly and NuGet metadata -->
    <Description>A dotnet tool for enhancing docfx behaviour and template/theme.</Description>
    <PackageTags>docfx plus plugin tool template Documentation API Metadata</PackageTags>
    <PackageReleaseNotes>
      <![CDATA[
        - **Fixed:** Color for `a:visited` should be only set for links under `.content`.  
          For example, in dark mode header nav and footer links were not keeping the original color.
          
        - **Fixed:** Avoid `nowrap` for name column in member tables and let names break on `<wbr>`.

        - **Fixed:** Header nav brand and buttons wrong wrapping on tablet size.
        
        - **Added:** If `codeSourceBasePath` from `metadata` in `docfx.json` is a relative path,  
          convert it to be relative to the `docfx.json` (`docfx` originally treats it relative to the working directory, which is wrong).

          Also convert backslashes (`\`) in code block's source attribute (`<code source="...">`) to forward slashes (`/`)  
          so that they are resolved correctly even when running on linux (e.g. when running in a Github Pages workflow which are usually linux based).  
          Since .NET 8, `System.IO.Path` methods does not do backslash mapping in Unix file paths  
          but we want to support existing projects which may have `<code source="...">` with backslashes all over the source code.
          
        - **Added:** `NamespaceDoc` support just like `SHFB`.  
          Namespace comments can be specified and maintained in your source code by adding an empty `NamespaceDoc` class to each namespace.  
          XML Comments (`<summary>` and `<remarks>` tags) from these classes will be extracted and assigned to the containing namespaces in the docs.
          
          ```c#
          namespace DotMake.CommandLine
          {
              /// <summary>
              /// This is the root namespace of this library, it includes the CLI attributes and CLI parser/runner.
              /// <para />
              /// <para>The main classes in this namespace are:</para>
              /// <list type="bullet">
              ///     <item><see cref="CliCommandAttribute"/> is the attribute which specifies a class that represents a command which is a specific action that the command line application performs.</item>
              ///     <item><see cref="CliOptionAttribute"/> is the attribute which specifies a class property that represents an option which is a named parameter and a value for that parameter, that is used on the command line.</item>
              /// </list>
              /// </summary>
              [System.Runtime.CompilerServices.CompilerGenerated]
              internal class NamespaceDoc
              {
              }
          }
          ```
          
          `NamespaceDoc` classes will be found even if your API filter excludes them but themselves will not be included in the docs,
          only their XML Comments assigned to the containing namespaces will be displayed.  
          You can optionally make them private or internal and mark them with a `CompilerGenerated` attribute.
      ]]>
    </PackageReleaseNotes>

    <!--<ErrorOnDuplicatePublishOutputFiles>false</ErrorOnDuplicatePublishOutputFiles>-->

  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Lib.Harmony" Version="2.4.1" />
  </ItemGroup>

  <ItemGroup>
    <!--
      So we have <PackageReference> with ExcludeAssets="All" so that the package reference is not added as a nuget dependency
      in our NuGet package, and with GeneratePathProperty="true" so that we can use <Reference> to reference the DLL from
      the package directly with HintPath.
      https://blog.maartenballiauw.be/post/2020/04/22/referencing-specific-assembly-nuget-package.html
    -->
    <PackageReference Include="docfx" Version="$(DocfxVersion)">
      <GeneratePathProperty>true</GeneratePathProperty>
      <IncludeAssets>None</IncludeAssets>
      <ExcludeAssets>All</ExcludeAssets>
      <PrivateAssets>None</PrivateAssets>
    </PackageReference>
    <Reference Include="docfx">
      <HintPath>$(Pkgdocfx)\tools\$(TargetFramework)\any\docfx.dll</HintPath>
    </Reference>
    <None Include="$(Pkgdocfx)\tools\$(TargetFramework)\any\**">
      <Link>%(RecursiveDir)%(Filename)%(Extension)</Link>
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
      <Visible>False</Visible>
    </None>

    <!-- required as we are referencing docfx as dll, these are needed to prevent conflicts -->
    <PackageReference Include="Docfx.App" Version="$(DocfxVersion)">
      <PrivateAssets>None</PrivateAssets>
    </PackageReference>
    <PackageReference Include="Docfx.Dotnet" Version="$(DocfxVersion)">
      <PrivateAssets>None</PrivateAssets>
    </PackageReference>
  </ItemGroup>

  <ItemGroup>
    <None Include="..\templates\**">
      <Link>templates\%(RecursiveDir)%(Filename)%(Extension)</Link>
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </None>
  </ItemGroup>

  <!-- Remove Node.js runtime dependencies that used by playwright -->
  <Target Name="RemoveNodeJsRuntimes" AfterTargets="CopyPlaywrightFilesToOutput">
    <ItemGroup>
      <!--<Content Remove="@(Content)" Condition="$([System.String]::Copy('%(Content.PlaywrightFolder)').Contains('node\'))" />-->
      <Content Remove="@(Content)" Condition="'%(Content.NuGetPackageId)' == 'Microsoft.Playwright'" />
    </ItemGroup>
  </Target>
</Project>
